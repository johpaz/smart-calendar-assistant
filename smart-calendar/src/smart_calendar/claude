import json
from datetime import datetime
from typing import Dict, List, Optional, Union
import langchain
from langchain_core.tools import tool
from langchain_openai import ChatOpenAI
from langgraph.graph import END, StateGraph
from langchain.agents import create_openai_functions_agent
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.messages import HumanMessage, AIMessage, BaseMessage
import operator
from typing import Annotated, Sequence, TypedDict
from flask import Flask, request, jsonify, render_template
from flask_cors import CORS

# Definición de la clase para la base de datos
class AgendaDB:
    def __init__(self):
        # Inicialización con eventos predeterminados
        self.eventos = [
            {
                "nombre": "Llamada con cliente",
                "fecha": "2025-03-10",
                "hora_inicio": "13:30",
                "hora_fin": "14:30"
            },
            {
                "nombre": "Revisión de código",
                "fecha": "2025-03-10",
                "hora_inicio": "15:00",
                "hora_fin": "16:00"
            }
        ]
    
    def obtener_todos_eventos(self) -> List[Dict]:
        """Devuelve todos los eventos en la agenda."""
        return self.eventos
    
    def agregar_evento(self, evento: Dict) -> Dict:
        """Agrega un nuevo evento a la agenda."""
        self.eventos.append(evento)
        return evento
    
    def eliminar_evento(self, nombre: str, fecha: str) -> bool:
        """Elimina un evento de la agenda por nombre y fecha."""
        for i, evento in enumerate(self.eventos):
            if evento["nombre"] == nombre and evento["fecha"] == fecha:
                del self.eventos[i]
                return True
        return False
    
    def actualizar_evento(self, nombre_original: str, fecha_original: str, evento_actualizado: Dict) -> Optional[Dict]:
        """Actualiza un evento existente."""
        for i, evento in enumerate(self.eventos):
            if evento["nombre"] == nombre_original and evento["fecha"] == fecha_original:
                self.eventos[i] = evento_actualizado
                return evento_actualizado
        return None
    
    def verificar_conflicto(self, fecha: str, hora_inicio: str, hora_fin: str) -> List[Dict]:
        """Verifica si hay conflictos de horario con eventos existentes."""
        conflictos = []
        
        # Convertir horas a objetos datetime para comparación
        nuevo_inicio = datetime.strptime(f"{fecha} {hora_inicio}", "%Y-%m-%d %H:%M")
        nuevo_fin = datetime.strptime(f"{fecha} {hora_fin}", "%Y-%m-%d %H:%M")
        
        for evento in self.eventos:
            if evento["fecha"] == fecha:
                evento_inicio = datetime.strptime(f"{fecha} {evento['hora_inicio']}", "%Y-%m-%d %H:%M")
                evento_fin = datetime.strptime(f"{fecha} {evento['hora_fin']}", "%Y-%m-%d %H:%M")
                
                # Verificar si hay superposición
                if (nuevo_inicio < evento_fin and nuevo_fin > evento_inicio):
                    conflictos.append(evento)
        
        return conflictos

# Instancia de la base de datos
db = AgendaDB()

# Herramientas para el agente
@tool
def agendar_reunion(nombre: str, fecha: str, hora_inicio: str, hora_fin: str) -> str:
    """
    Agenda una nueva reunión verificando conflictos.
    
    Args:
        nombre: Nombre de la reunión
        fecha: Fecha en formato YYYY-MM-DD
        hora_inicio: Hora de inicio en formato HH:MM
        hora_fin: Hora de fin en formato HH:MM
    
    Returns:
        Respuesta en formato JSON indicando éxito o conflicto
    """
    conflictos = db.verificar_conflicto(fecha, hora_inicio, hora_fin)
    
    if conflictos:
        return json.dumps({
            "status": "conflict",
            "mensaje": "No se puede agendar la reunión debido a conflictos.",
            "conflictos": conflictos
        }, indent=2)
    
    nuevo_evento = {
        "nombre": nombre,
        "fecha": fecha,
        "hora_inicio": hora_inicio,
        "hora_fin": hora_fin
    }
    
    db.agregar_evento(nuevo_evento)
    
    return json.dumps({
        "status": "success",
        "mensaje": "Reunión agendada con éxito.",
        "evento": nuevo_evento
    }, indent=2)

@tool
def consultar_agenda(fecha: Optional[str] = None) -> str:
    """
    Consulta eventos en la agenda, opcionalmente filtrados por fecha.
    
    Args:
        fecha: Fecha opcional en formato YYYY-MM-DD para filtrar
    
    Returns:
        Lista de eventos en formato JSON
    """
    eventos = db.obtener_todos_eventos()
    
    if fecha:
        eventos = [evento for evento in eventos if evento["fecha"] == fecha]
    
    return json.dumps({
        "status": "success",
        "eventos": eventos
    }, indent=2)

@tool
def eliminar_reunion(nombre: str, fecha: str) -> str:
    """
    Elimina una reunión existente.
    
    Args:
        nombre: Nombre de la reunión a eliminar
        fecha: Fecha de la reunión a eliminar
    
    Returns:
        Respuesta en formato JSON indicando éxito o fracaso
    """
    exito = db.eliminar_evento(nombre, fecha)
    
    if exito:
        return json.dumps({
            "status": "success",
            "mensaje": f"Reunión '{nombre}' del {fecha} eliminada con éxito."
        }, indent=2)
    else:
        return json.dumps({
            "status": "error",
            "mensaje": f"No se encontró la reunión '{nombre}' del {fecha}."
        }, indent=2)

@tool
def actualizar_reunion(nombre_original: str, fecha_original: str, nuevo_nombre: str, 
                       nueva_fecha: str, nueva_hora_inicio: str, nueva_hora_fin: str) -> str:
    """
    Actualiza los detalles de una reunión existente.
    
    Args:
        nombre_original: Nombre actual de la reunión
        fecha_original: Fecha actual de la reunión
        nuevo_nombre: Nuevo nombre para la reunión
        nueva_fecha: Nueva fecha para la reunión
        nueva_hora_inicio: Nueva hora de inicio
        nueva_hora_fin: Nueva hora de fin
    
    Returns:
        Respuesta en formato JSON indicando éxito o fracaso
    """
    # Verificar que la reunión original existe
    eventos = db.obtener_todos_eventos()
    reunion_existe = any(e["nombre"] == nombre_original and e["fecha"] == fecha_original for e in eventos)
    
    if not reunion_existe:
        return json.dumps({
            "status": "error",
            "mensaje": f"No se encontró la reunión '{nombre_original}' del {fecha_original}."
        }, indent=2)
    
    # Verificar conflictos para la nueva hora/fecha (excluyendo la reunión actual)
    conflictos = []
    
    # Convertir horas a objetos datetime para comparación
    nuevo_inicio = datetime.strptime(f"{nueva_fecha} {nueva_hora_inicio}", "%Y-%m-%d %H:%M")
    nuevo_fin = datetime.strptime(f"{nueva_fecha} {nueva_hora_fin}", "%Y-%m-%d %H:%M")
    
    for evento in eventos:
        # Excluir el evento que estamos actualizando
        if evento["nombre"] == nombre_original and evento["fecha"] == fecha_original:
            continue
            
        if evento["fecha"] == nueva_fecha:
            evento_inicio = datetime.strptime(f"{nueva_fecha} {evento['hora_inicio']}", "%Y-%m-%d %H:%M")
            evento_fin = datetime.strptime(f"{nueva_fecha} {evento['hora_fin']}", "%Y-%m-%d %H:%M")
            
            # Verificar si hay superposición
            if (nuevo_inicio < evento_fin and nuevo_fin > evento_inicio):
                conflictos.append(evento)
    
    if conflictos:
        return json.dumps({
            "status": "conflict",
            "mensaje": "La actualización genera conflictos con otros eventos.",
            "conflictos": conflictos
        }, indent=2)
    
    evento_actualizado = {
        "nombre": nuevo_nombre,
        "fecha": nueva_fecha,
        "hora_inicio": nueva_hora_inicio,
        "hora_fin": nueva_hora_fin
    }
    
    resultado = db.actualizar_evento(nombre_original, fecha_original, evento_actualizado)
    
    return json.dumps({
        "status": "success",
        "mensaje": f"Reunión actualizada con éxito.",
        "evento": resultado
    }, indent=2)

# Definir el estado para el flujo del agente
class AgentState(TypedDict):
    messages: Annotated[Sequence[BaseMessage], operator.add]
    
# Configurar el modelo LLM
llm = ChatOpenAI(temperature=0, model="gpt-3.5-turbo-0125")

# Crear el prompt para el agente
prompt = ChatPromptTemplate.from_messages([
    ("system", """
    Eres un asistente de agenda inteligente. Tu función es ayudar a gestionar reuniones y eventos.
    Puedes crear nuevas reuniones, verificar conflictos, consultar la agenda, actualizar y eliminar reuniones.
    
    Siempre responde con información precisa y completa. Cuando proceses solicitudes, responde con 
    datos en formato JSON y explicaciones claras sobre las acciones realizadas.
    
    Para agendar reuniones, verifica siempre los conflictos primero. Una reunión tiene conflicto
    si se superpone con otra reunión existente en la misma fecha.
    
    Usa las herramientas disponibles para interactuar con la base de datos de la agenda.
    """),
    ("human", "{input}"),
])

# Crear el agente con las herramientas
tools = [agendar_reunion, consultar_agenda, eliminar_reunion, actualizar_reunion]
agent = create_openai_functions_agent(llm, tools, prompt)

# Crear el grafo para el flujo del agente
workflow = StateGraph(AgentState)
workflow.add_node("agent", agent)
workflow.set_entry_point("agent")
workflow.add_edge("agent", END)
graph = workflow.compile()

# Función para procesar solicitudes
def procesar_solicitud(solicitud):
    if isinstance(solicitud, str):
        # Si es una cadena de texto, intentar parsear JSON
        try:
            data = json.loads(solicitud)
        except json.JSONDecodeError:
            # Si no es JSON válido, asumimos que es una consulta en lenguaje natural
            return ejecutar_agente(solicitud)
    else:
        # Si ya es un diccionario
        data = solicitud
    
    # Procesar según el tipo de solicitud
    if "solicitud" in data:
        tipo_solicitud = data.get("solicitud")
        
        if tipo_solicitud == "agendar":
            return ejecutar_agente(f"Quiero agendar una reunión con el nombre '{data.get('nombre')}' para el {data.get('fecha')} desde las {data.get('hora_inicio')} hasta las {data.get('hora_fin')}")
        
        elif tipo_solicitud == "consultar":
            fecha = data.get("fecha", None)
            if fecha:
                return ejecutar_agente(f"Muéstrame las reuniones para el {fecha}")
            else:
                return ejecutar_agente("Muéstrame todas las reuniones en la agenda")
        
        elif tipo_solicitud == "eliminar":
            return ejecutar_agente(f"Elimina la reunión '{data.get('nombre')}' del {data.get('fecha')}")
        
        elif tipo_solicitud == "actualizar":
            return ejecutar_agente(
                f"Actualiza la reunión '{data.get('nombre_original')}' del {data.get('fecha_original')} "
                f"con nuevo nombre '{data.get('nuevo_nombre')}', nueva fecha {data.get('nueva_fecha')}, "
                f"nueva hora inicio {data.get('nueva_hora_inicio')} y nueva hora fin {data.get('nueva_hora_fin')}"
            )
    
    # Si no se reconoce la solicitud, pasarla como texto al agente
    return ejecutar_agente(json.dumps(data))

# Función para ejecutar el agente
def ejecutar_agente(input_text):
    result = graph.invoke({
        "messages": [HumanMessage(content=input_text)]
    })
    return result["messages"][-1].content

# Configuración de la aplicación Flask
app = Flask(__name__)
CORS(app)

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/chat', methods=['POST'])
def chat():
    data = request.json
    mensaje = data.get('mensaje', '')
    
    respuesta = procesar_solicitud(mensaje)
    
    return jsonify({'respuesta': respuesta})

# Agregar ruta para procesar JSON directamente
@app.route('/api/agenda', methods=['POST'])
def api_agenda():
    data = request.json
    respuesta = procesar_solicitud(data)
    
    # Intentar convertir la respuesta a JSON si es una cadena
    if isinstance(respuesta, str):
        try:
            respuesta_json = json.loads(respuesta)
            return jsonify(respuesta_json)
        except json.JSONDecodeError:
            return jsonify({'respuesta': respuesta})
    
    return jsonify({'respuesta': respuesta})

if __name__ == '__main__':
    app.run(debug=True)